import { json } from '@sveltejs/kit';
import { error } from '@sveltejs/kit';

const NVDAPI_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
const CACHE_DURATION = 3600000; // 1 hour
const STALE_CACHE_DURATION = 86400000; // 24 hours
const REQUEST_TIMEOUT = 8000;

// In-memory cache with timestamps and hit counts
const cache = new Map();

/**
 * Cleans up old cache entries
 */
function cleanupCache() {
    const now = Date.now();
    for (const [key, value] of cache.entries()) {
        if (now - value.timestamp > STALE_CACHE_DURATION) {
            cache.delete(key);
        }
    }
}

/**
 * Creates a timeout promise that can be cleaned up
 */
function createTimeout(ms, signal) {
    return new Promise((_, reject) => {
        const timeoutId = setTimeout(() => {
            reject(new Error('Request timeout'));
        }, ms);

        // Clean up timeout if the request completes or is aborted
        signal?.addEventListener('abort', () => {
            clearTimeout(timeoutId);
        });
    });
}

/**
 * Normalizes CVE data from NVD API response
 */
function normalizeCveData(cve, cveId) {
    if (!cve) {
        throw new Error('CVE data not found');
    }

    const metrics = cve.metrics?.cvssMetricV31?.[0]?.cvssData || 
                   cve.metrics?.cvssMetricV30?.[0]?.cvssData ||
                   cve.metrics?.cvssMetricV2?.[0]?.cvssData;

    return {
        id: cveId,
        cvss: metrics?.baseScore || null,
        severity: metrics?.baseSeverity || null,
        summary: cve.descriptions?.[0]?.value || null,
        references: cve.references || [],
        published: cve.published,
        lastModified: cve.lastModified,
        weaknesses: cve.weaknesses || [],
        configurations: cve.configurations || []
    };
}

/**
 * @param {import('@sveltejs/kit').RequestEvent} event
 */
export async function GET({ params, setHeaders }) {
    const cveId = params.id;
    const controller = new AbortController();
    
    try {
        // Clean up old cache entries periodically
        cleanupCache();

        // Check cache first
        const cached = cache.get(cveId);
        if (cached) {
            const age = Date.now() - cached.timestamp;
            
            if (age < CACHE_DURATION) {
                setHeaders({
                    'Cache-Control': `public, max-age=${Math.floor((CACHE_DURATION - age) / 1000)}`,
                    'X-Cache': 'HIT'
                });
                cached.hits++;
                return json(cached.data);
            }

            // Use stale cache while revalidating
            if (age < STALE_CACHE_DURATION) {
                setHeaders({
                    'Cache-Control': 'public, max-age=300',
                    'X-Cache': 'STALE'
                });
                // Don't wait for revalidation
                revalidateCache(cveId).catch(console.error);
                return json({ ...cached.data, stale: true });
            }
        }

        const response = await Promise.race([
            fetch(`${NVDAPI_URL}?cveId=${cveId}`, {
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'CVE-PoC-Tracker/1.0'
                },
                signal: controller.signal
            }),
            createTimeout(REQUEST_TIMEOUT, controller.signal)
        ]);

        if (response.status === 429) {
            throw error(429, {
                message: 'Rate limit exceeded',
                headers: {
                    'Retry-After': response.headers.get('Retry-After') || '60'
                }
            });
        }

        if (!response.ok) {
            throw error(response.status, 'NVD API error');
        }

        const data = await response.json();
        const normalizedData = normalizeCveData(data.vulnerabilities?.[0]?.cve, cveId);

        // Cache the normalized data
        cache.set(cveId, {
            data: normalizedData,
            timestamp: Date.now(),
            hits: 1
        });

        setHeaders({
            'Cache-Control': 'public, max-age=3600',
            'X-Cache': 'MISS'
        });

        return json(normalizedData);

    } catch (err) {
        controller.abort(); // Ensure any pending requests are cancelled
        console.error(`Error fetching CVE ${cveId}:`, err);

        // Return stale cache if available
        const staleCache = cache.get(cveId);
        if (staleCache) {
            setHeaders({
                'Cache-Control': 'public, max-age=300',
                'X-Cache': 'STALE'
            });
            return json({
                ...staleCache.data,
                stale: true
            });
        }

        // Handle specific error types
        if (err.status === 429) {
            throw error(429, {
                message: 'Rate limit exceeded',
                headers: err.headers
            });
        }

        throw error(503, 'Service temporarily unavailable');
    }
}

/**
 * Revalidates cached data in the background
 */
async function revalidateCache(cveId) {
    const controller = new AbortController();
    
    try {
        const response = await Promise.race([
            fetch(`${NVDAPI_URL}?cveId=${cveId}`, {
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'CVE-PoC-Tracker/1.0'
                },
                signal: controller.signal
            }),
            createTimeout(REQUEST_TIMEOUT, controller.signal)
        ]);

        if (!response.ok) return;

        const data = await response.json();
        const normalizedData = normalizeCveData(data.vulnerabilities?.[0]?.cve, cveId);

        cache.set(cveId, {
            data: normalizedData,
            timestamp: Date.now(),
            hits: cache.get(cveId)?.hits || 0
        });
    } catch (error) {
        console.warn(`Background revalidation failed for ${cveId}:`, error);
    } finally {
        controller.abort(); // Clean up any pending requests
    }
}