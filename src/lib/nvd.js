const API_BASE_URL = '/api/cve';

/**
 * Fetches CVE details with retries and proper error handling
 * @param {string} cveId
 * @returns {Promise<any>}
 */
export async function fetchCveDetails(cveId) {
    const maxRetries = 2;
    const retryDelay = 1000;
    let lastError = null;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
            const response = await fetch(`${API_BASE_URL}/${cveId}`, {
                headers: {
                    'Accept': 'application/json',
                    'Cache-Control': 'no-cache'
                }
            });

            if (response.status === 429) {
                const retryAfter = parseInt(response.headers.get('Retry-After') || '60', 10);
                await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                continue;
            }

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            return data;

        } catch (error) {
            lastError = error;
            
            if (error.name === 'AbortError') {
                console.warn(`Timeout fetching CVE ${cveId}, attempt ${attempt + 1}/${maxRetries + 1}`);
            } else {
                console.warn(`Error fetching CVE ${cveId}, attempt ${attempt + 1}/${maxRetries + 1}:`, error.message);
            }

            if (attempt === maxRetries) {
                break;
            }

            await new Promise(resolve => setTimeout(resolve, retryDelay * Math.pow(2, attempt)));
        }
    }

    console.error(`Failed to fetch CVE ${cveId} after ${maxRetries + 1} attempts:`, lastError);
    return null;
}

/**
 * Gets severity info based on CVSS score
 * @param {number} score
 * @returns {{color: string, label: string, description: string}}
 */
export function getSeverityColor(score) {
    if (!score || typeof score !== 'number') return {
        color: '#666666',
        label: 'Unknown',
        description: 'CVSS score not available'
    };

    if (score >= 9.0) return {
        color: '#ff0000',
        label: 'Critical',
        description: 'Total system compromise, remote code execution, or critical impact'
    };
    if (score >= 7.0) return {
        color: '#ff4400',
        label: 'High',
        description: 'Significant impact, potential for system compromise'
    };
    if (score >= 4.0) return {
        color: '#ff8800',
        label: 'Medium',
        description: 'Partial impact, requires user interaction or specific conditions'
    };
    return {
        color: '#00cc00',
        label: 'Low',
        description: 'Minimal impact, requires local access or unlikely conditions'
    };
}

/**
 * Extracts CVE ID from title or description
 * @param {string} text
 * @returns {string|null}
 */
export function extractCveId(text) {
    if (!text) return null;
    const match = text.match(/CVE-\d{4}-\d{4,7}/i);
    return match ? match[0].toUpperCase() : null;
}