import { cveCache, failedRequests, requestStatus } from '../stores/cveStore';
import { get } from 'svelte/store';
import { RequestQueue } from './queue';

const API_BASE_URL = '/api/cve';
const MAX_RETRIES = 2;
const INITIAL_RETRY_DELAY = 1000;
const REQUEST_TIMEOUT = 10000; // 10 seconds

// Create a rate-limited request queue
const requestQueue = new RequestQueue(2, 500); // 2 concurrent requests, 500ms delay between requests

/**
 * Creates a timeout promise
 * @param {number} ms
 * @returns {Promise<never>}
 */
function timeout(ms) {
    return new Promise((_, reject) => {
        setTimeout(() => {
            reject(new Error('Request timeout'));
        }, ms);
    });
}

/**
 * Fetches CVE details with retries and proper error handling
 * @param {string} cveId
 * @returns {Promise<any>}
 */
export async function fetchCveDetails(cveId) {
    try {
        // Update request status
        requestStatus.update(s => {
            s.pending.add(cveId);
            return s;
        });

        // Check cache first
        const cache = get(cveCache);
        if (cache.has(cveId)) {
            requestStatus.update(s => {
                s.pending.delete(cveId);
                s.completed.add(cveId);
                return s;
            });
            return cache.get(cveId);
        }

        // Check if we've failed to fetch this CVE before
        const failed = get(failedRequests);
        if (failed.has(cveId)) {
            requestStatus.update(s => {
                s.pending.delete(cveId);
                s.failed.add(cveId);
                return s;
            });
            return null;
        }

        const fetchWithTimeout = async () => {
            try {
                const response = await Promise.race([
                    fetch(`${API_BASE_URL}/${cveId}`, {
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        }
                    }),
                    timeout(REQUEST_TIMEOUT)
                ]);

                if (response.status === 429) {
                    const retryAfter = parseInt(response.headers.get('Retry-After') || '60', 10);
                    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                    throw new Error('Rate limited');
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                return data;
            } catch (error) {
                if (error.message === 'Request timeout') {
                    throw new Error('Request timeout');
                }
                throw error;
            }
        };

        // Add request to queue with retries
        const data = await requestQueue.add(async () => {
            let lastError = null;

            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                try {
                    const data = await fetchWithTimeout();
                    return data;
                } catch (error) {
                    lastError = error;
                    if (attempt < MAX_RETRIES) {
                        const delay = INITIAL_RETRY_DELAY * Math.pow(2, attempt);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }

            throw lastError;
        });

        // Cache successful response
        cveCache.update(c => c.set(cveId, data));
        
        requestStatus.update(s => {
            s.pending.delete(cveId);
            s.completed.add(cveId);
            return s;
        });

        return data;

    } catch (error) {
        console.error(`Failed to fetch CVE ${cveId}:`, error.message);
        
        requestStatus.update(s => {
            s.pending.delete(cveId);
            s.failed.add(cveId);
            return s;
        });

        // Return cached data if available, even if expired
        const cache = get(cveCache);
        const staleCache = cache.get(cveId);
        if (staleCache) {
            return {
                ...staleCache,
                stale: true
            };
        }

        // Mark as failed and return null
        failedRequests.update(f => f.add(cveId));
        return null;
    }
}