/**
 * A rate-limited request queue with proper error handling
 */
export class RequestQueue {
    constructor(maxConcurrent = 2, requestDelay = 500) {
        this.queue = [];
        this.running = 0;
        this.maxConcurrent = maxConcurrent;
        this.requestDelay = requestDelay;
        this.lastRequestTime = 0;
        this.processing = false;
    }

    /**
     * Adds a function to the queue
     * @template T
     * @param {() => Promise<T>} fn
     * @returns {Promise<T>}
     */
    async add(fn) {
        if (typeof fn !== 'function') {
            throw new Error('Queue item must be a function');
        }

        return new Promise((resolve, reject) => {
            const queueItem = {
                fn,
                resolve: (value) => {
                    resolve(value);
                    this.processNextItem();
                },
                reject: (error) => {
                    reject(error);
                    this.processNextItem();
                }
            };

            this.queue.push(queueItem);
            this.processNextItem();
        });
    }

    /**
     * Process the next item in the queue
     * @private
     */
    async processNextItem() {
        if (this.processing || this.running >= this.maxConcurrent || this.queue.length === 0) {
            return;
        }

        this.processing = true;
        this.running++;

        try {
            const item = this.queue.shift();
            if (!item) {
                return;
            }

            // Ensure minimum delay between requests
            const now = Date.now();
            const timeSinceLastRequest = now - this.lastRequestTime;
            if (timeSinceLastRequest < this.requestDelay) {
                await new Promise(r => setTimeout(r, this.requestDelay - timeSinceLastRequest));
            }

            this.lastRequestTime = Date.now();

            try {
                const result = await item.fn();
                item.resolve(result);
            } catch (error) {
                item.reject(error);
            }
        } catch (error) {
            console.error('Queue processing error:', error);
        } finally {
            this.running--;
            this.processing = false;
            
            // Check for more items to process
            if (this.queue.length > 0) {
                this.processNextItem();
            }
        }
    }

    /**
     * Clears the queue and rejects all pending items
     */
    clear() {
        const error = new Error('Queue cleared');
        while (this.queue.length > 0) {
            const item = this.queue.shift();
            if (item) {
                item.reject(error);
            }
        }
        this.running = 0;
        this.processing = false;
    }
}